<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Maker | デザイナー向けパターン生成ツール</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for Icons (Web Font) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #fdf2f8; /* pink-50 */
            height: 100vh;
            overflow: hidden;
        }
        
        .custom-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: transparent;
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background-color: #fbcfe8; /* pink-200 */
            border-radius: 20px;
        }

        .checkered-bg {
            background-image: 
                linear-gradient(45deg, #e5e7eb 25%, transparent 25%, transparent 75%, #e5e7eb 75%),
                linear-gradient(45deg, #e5e7eb 25%, transparent 25%, transparent 75%, #e5e7eb 75%);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }

        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #db2777; /* pink-600 */
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e2e8f0;
            border-radius: 2px;
        }

        /* アイコンボタンのスタイル調整 */
        .shape-btn i {
            font-size: 1.25rem; /* 20px */
            pointer-events: none;
        }
    </style>
</head>
<body class="flex flex-col md:flex-row h-screen text-gray-800">

    <!-- 左サイドバー: 設定パネル -->
    <aside class="w-full md:w-80 bg-white shadow-xl z-10 flex flex-col h-full border-r border-gray-200">
        <div class="p-5 border-b border-gray-100 flex justify-between items-center">
            <h1 class="text-xl font-bold text-pink-600 flex items-center gap-2">
                <i class="fa-solid fa-shapes"></i> Pattern Maker
            </h1>
            <button id="randomBtn" class="text-xs bg-pink-50 text-pink-600 px-2 py-1 rounded hover:bg-pink-100 transition" title="ランダム生成">
                <i class="fa-solid fa-dice"></i> Random
            </button>
        </div>

        <div class="flex-1 overflow-y-auto custom-scroll p-5 space-y-6">
            
            <!-- Shape Selection -->
            <div class="space-y-2">
                <label class="text-xs font-bold text-gray-500 uppercase tracking-wider">図形 (Shape)</label>
                <div class="grid grid-cols-4 gap-2">
                    
                    <!-- Line Patterns (New) -->
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="stripe" title="ストライプ">
                        <i class="fa-solid fa-grip-lines-vertical text-gray-600 text-sm"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="grid" title="方眼 (グリッド)">
                        <i class="fa-solid fa-border-all text-gray-600 text-sm"></i>
                    </button>
                    <!-- Spacer for alignment if needed, or just Basic Geometry starts here -->
                    
                    <!-- Basic Geometry -->
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="circle" title="円">
                        <i class="fa-regular fa-circle text-gray-600 text-sm"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="square" title="四角">
                        <i class="fa-regular fa-square text-gray-600 text-sm"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="triangle" title="三角">
                        <i class="fa-solid fa-play -rotate-90 text-[10px] text-gray-600"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="cross" title="バツ">
                        <i class="fa-solid fa-xmark text-gray-600 text-sm"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="diamond" title="ひし形">
                        <i class="fa-solid fa-diamond text-[10px] text-gray-600"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="wave" title="波線">
                        <i class="fa-solid fa-water text-gray-600 text-xs"></i>
                    </button>
                    
                    <!-- Font Awesome Icons -->
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="star" title="星">
                        <i class="fa-solid fa-star text-gray-600 text-xs"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="heart" title="ハート">
                        <i class="fa-solid fa-heart text-gray-600 text-xs"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="bolt" title="稲妻">
                        <i class="fa-solid fa-bolt text-gray-600 text-xs"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="moon" title="月">
                        <i class="fa-solid fa-moon text-gray-600 text-xs"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="cloud" title="雲">
                        <i class="fa-solid fa-cloud text-gray-600 text-xs"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="leaf" title="葉">
                        <i class="fa-solid fa-leaf text-gray-600 text-xs"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="snowflake" title="雪">
                        <i class="fa-solid fa-snowflake text-gray-600 text-xs"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="flower" title="花">
                        <i class="fa-solid fa-spa text-gray-600 text-xs"></i>
                    </button>
                </div>
            </div>

            <!-- Seamless Mode Switch -->
            <div class="bg-pink-50 p-3 rounded-lg border border-pink-100">
                <label class="flex items-center gap-3 cursor-pointer">
                    <div class="relative">
                        <input type="checkbox" id="seamlessMode" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-300 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-pink-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-pink-600"></div>
                    </div>
                    <div class="flex flex-col">
                        <span class="text-sm font-bold text-pink-900">シームレスモード</span>
                        <span class="text-[10px] text-pink-700 leading-tight">端が繋がるよう自動調整</span>
                    </div>
                </label>
            </div>

            <!-- Colors -->
            <div class="space-y-3">
                <label class="text-xs font-bold text-gray-500 uppercase tracking-wider">カラー (Colors)</label>
                <div class="flex items-center justify-between">
                    <span class="text-sm text-gray-600">図形/線色</span>
                    <div class="flex items-center gap-2">
                        <input type="color" id="shapeColor" value="#333333" class="w-8 h-8 rounded cursor-pointer border-0 p-0">
                        <input type="range" id="opacity" min="0.1" max="1" step="0.1" value="1" class="w-20" title="不透明度">
                    </div>
                </div>
                <div class="flex items-center justify-between">
                    <span class="text-sm text-gray-600">背景色</span>
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="transparentBg" class="w-4 h-4 text-pink-600 rounded focus:ring-pink-500" title="透明背景">
                        <span class="text-xs text-gray-400 mr-2">透明</span>
                        <input type="color" id="bgColor" value="#ffffff" class="w-8 h-8 rounded cursor-pointer border-0 p-0">
                    </div>
                </div>
            </div>

            <!-- Parameters -->
            <div class="space-y-4">
                <label class="text-xs font-bold text-gray-500 uppercase tracking-wider">パラメーター (Params)</label>
                
                <div class="space-y-1">
                    <div class="flex justify-between text-sm">
                        <span>サイズ (Spacing Adjust)</span>
                        <span id="sizeVal" class="text-gray-400 text-xs">30px</span>
                    </div>
                    <input type="range" id="size" min="2" max="150" value="30" class="w-full">
                </div>

                <div class="space-y-1">
                    <div class="flex justify-between text-sm">
                        <span>間隔 (Gap)</span>
                        <span id="gapVal" class="text-gray-400 text-xs">40px</span>
                    </div>
                    <input type="range" id="gap" min="0" max="200" value="40" class="w-full">
                </div>

                <div class="space-y-1">
                    <div class="flex justify-between text-sm">
                        <span>回転 (Rotation)</span>
                        <span id="rotVal" class="text-gray-400 text-xs">0°</span>
                    </div>
                    <input type="range" id="rotation" min="0" max="360" value="0" class="w-full">
                </div>
                
                 <div class="space-y-1">
                    <div class="flex justify-between text-sm">
                        <span>線の太さ (Stroke)</span>
                        <span id="strokeVal" class="text-gray-400 text-xs">Normal</span>
                    </div>
                    <input type="range" id="strokeWidth" min="1" max="50" value="2" class="w-full">
                    <p class="text-[10px] text-gray-400">*バツやライン、ストライプに有効</p>
                </div>
            </div>

            <!-- Layout Options -->
            <div class="space-y-3">
                <label class="text-xs font-bold text-gray-500 uppercase tracking-wider">レイアウト (Layout)</label>
                
                <label class="flex items-center gap-2 cursor-pointer p-2 rounded hover:bg-gray-50">
                    <input type="checkbox" id="offsetRow" class="w-4 h-4 text-pink-600 rounded focus:ring-pink-500" checked>
                    <span class="text-sm text-gray-700">千鳥配置 (Offset Rows)</span>
                </label>
                
                <label class="flex items-center gap-2 cursor-pointer p-2 rounded hover:bg-gray-50">
                    <input type="checkbox" id="randomizePos" class="w-4 h-4 text-pink-600 rounded focus:ring-pink-500">
                    <span class="text-sm text-gray-700">位置を少しランダムに (Jitter)</span>
                    <span class="text-[10px] text-red-400 ml-1 hidden" id="jitterWarning">※シームレスにはなりません</span>
                </label>
            </div>

        </div>

        <!-- Download Action -->
        <div class="p-5 border-t border-gray-200 bg-gray-50">
            <button id="downloadBtn" class="w-full bg-pink-600 text-white font-semibold py-3 px-4 rounded-lg shadow hover:bg-pink-700 transition flex justify-center items-center gap-2">
                <i class="fa-solid fa-download"></i> ダウンロード (PNG)
            </button>
            <p class="text-xs text-center text-gray-400 mt-2">2000 x 2000px で出力されます</p>
        </div>
    </aside>

    <!-- 右側: プレビューエリア -->
    <main class="flex-1 relative flex flex-col min-w-0">
        <!-- キャンバスエリア -->
        <div class="flex-1 relative overflow-hidden flex items-center justify-center p-4 md:p-10 checkered-bg bg-gray-100">
            <div class="relative shadow-2xl bg-white">
                <!-- 実際に描画されるキャンバス -->
                <canvas id="mainCanvas" width="2000" height="2000" class="max-w-full max-h-[80vh] w-auto h-auto object-contain"></canvas>
                
                <!-- サイズ表示ラベル -->
                <div class="absolute -top-6 left-0 text-xs text-gray-500 font-mono">Preview (2000x2000px)</div>
                <!-- シームレス表示バッジ -->
                <div id="seamlessBadge" class="absolute top-2 right-2 bg-pink-600 text-white text-[10px] px-2 py-1 rounded shadow hidden">Seamless ON</div>
            </div>
        </div>
    </main>

    <script>
        // DOM要素の取得
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        
        // 状態管理
        const state = {
            shape: 'stripe', // デフォルトを変えてみても良い
            color: '#333333',
            opacity: 1,
            bgColor: '#ffffff',
            transparentBg: false,
            size: 30,
            gap: 40,
            rotation: 0,
            strokeWidth: 2,
            offsetRow: true,
            randomizePos: false,
            seamlessMode: false,
            canvasSize: 2000
        };

        // 入力要素のマッピング
        const inputs = {
            shapeBtns: document.querySelectorAll('.shape-btn'),
            color: document.getElementById('shapeColor'),
            opacity: document.getElementById('opacity'),
            bgColor: document.getElementById('bgColor'),
            transparentBg: document.getElementById('transparentBg'),
            size: document.getElementById('size'),
            gap: document.getElementById('gap'),
            rotation: document.getElementById('rotation'),
            strokeWidth: document.getElementById('strokeWidth'),
            offsetRow: document.getElementById('offsetRow'),
            randomizePos: document.getElementById('randomizePos'),
            seamlessMode: document.getElementById('seamlessMode'),
            downloadBtn: document.getElementById('downloadBtn'),
            randomBtn: document.getElementById('randomBtn')
        };

        // 値表示用要素
        const labels = {
            size: document.getElementById('sizeVal'),
            gap: document.getElementById('gapVal'),
            rotation: document.getElementById('rotVal'),
            stroke: document.getElementById('strokeVal')
        };

        const jitterWarning = document.getElementById('jitterWarning');
        const seamlessBadge = document.getElementById('seamlessBadge');

        // Font Awesome Icons Unicode Map
        const faIcons = {
            'star': '\uf005',
            'heart': '\uf004',
            'bolt': '\uf0e7',
            'moon': '\uf186',
            'cloud': '\uf0c2',
            'leaf': '\uf06c',
            'snowflake': '\uf2dc',
            'flower': '\uf06c', 
            'music': '\uf001',
            'ghost': '\uf6e2',
            'cat': '\uf6be',
            'paw': '\uf1b0'
        };

        // 初期化
        function init() {
            addEventListeners();
            updateUI();
            
            // Webフォント読み込み待ち（簡易対応）
            document.fonts.ready.then(() => {
                draw();
            });
            draw();
        }

        // イベントリスナーの設定
        function addEventListeners() {
            inputs.shapeBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    inputs.shapeBtns.forEach(b => {
                        b.classList.remove('border-pink-500', 'bg-pink-50', 'ring-2', 'ring-pink-200');
                        b.classList.add('border-gray-200');
                    });
                    
                    const target = e.currentTarget;
                    target.classList.remove('border-gray-200');
                    target.classList.add('border-pink-500', 'bg-pink-50', 'ring-2', 'ring-pink-200');
                    
                    state.shape = target.dataset.shape;
                    draw();
                });
            });

            const activeBtn = document.querySelector(`[data-shape="${state.shape}"]`);
            if(activeBtn) {
                activeBtn.classList.remove('border-gray-200');
                activeBtn.classList.add('border-pink-500', 'bg-pink-50', 'ring-2', 'ring-pink-200');
            }

            const updateStateAndDraw = (key, value) => {
                state[key] = value;
                updateLabels();
                draw();
            };

            inputs.color.addEventListener('input', e => updateStateAndDraw('color', e.target.value));
            inputs.opacity.addEventListener('input', e => updateStateAndDraw('opacity', parseFloat(e.target.value)));
            inputs.bgColor.addEventListener('input', e => updateStateAndDraw('bgColor', e.target.value));
            
            inputs.transparentBg.addEventListener('change', e => {
                state.transparentBg = e.target.checked;
                inputs.bgColor.disabled = state.transparentBg;
                inputs.bgColor.parentElement.style.opacity = state.transparentBg ? 0.5 : 1;
                draw();
            });

            inputs.size.addEventListener('input', e => updateStateAndDraw('size', parseInt(e.target.value)));
            inputs.gap.addEventListener('input', e => updateStateAndDraw('gap', parseInt(e.target.value)));
            inputs.rotation.addEventListener('input', e => updateStateAndDraw('rotation', parseInt(e.target.value)));
            inputs.strokeWidth.addEventListener('input', e => updateStateAndDraw('strokeWidth', parseInt(e.target.value)));
            
            inputs.offsetRow.addEventListener('change', e => updateStateAndDraw('offsetRow', e.target.checked));
            inputs.randomizePos.addEventListener('change', e => updateStateAndDraw('randomizePos', e.target.checked));
            inputs.seamlessMode.addEventListener('change', e => updateStateAndDraw('seamlessMode', e.target.checked));

            inputs.downloadBtn.addEventListener('click', downloadImage);
            inputs.randomBtn.addEventListener('click', generateRandom);
        }

        function updateLabels() {
            labels.size.textContent = `${state.size}px`;
            labels.gap.textContent = `${state.gap}px`;
            labels.rotation.textContent = `${state.rotation}°`;
            labels.stroke.textContent = `${state.strokeWidth}px`;
            
            // UI制御
            if(state.seamlessMode && state.randomizePos) {
                jitterWarning.classList.remove('hidden');
            } else {
                jitterWarning.classList.add('hidden');
            }

            if(state.seamlessMode) {
                seamlessBadge.classList.remove('hidden');
            } else {
                seamlessBadge.classList.add('hidden');
            }

            // ストライプ・グリッドのときは千鳥配置オプションを無効化（意味がないため）
            if (state.shape === 'stripe' || state.shape === 'grid') {
                inputs.offsetRow.parentElement.classList.add('opacity-50', 'pointer-events-none');
                inputs.randomizePos.parentElement.classList.add('opacity-50', 'pointer-events-none');
            } else {
                inputs.offsetRow.parentElement.classList.remove('opacity-50', 'pointer-events-none');
                inputs.randomizePos.parentElement.classList.remove('opacity-50', 'pointer-events-none');
            }
        }

        function updateUI() {
            inputs.color.value = state.color;
            inputs.size.value = state.size;
            inputs.gap.value = state.gap;
            inputs.rotation.value = state.rotation;
            inputs.seamlessMode.checked = state.seamlessMode;
            updateLabels();
        }

        function generateRandom() {
            const pathShapes = ['circle', 'square', 'triangle', 'cross', 'diamond', 'line', 'wave', 'dot', 'stripe', 'grid'];
            const iconShapes = Object.keys(faIcons);
            const allShapes = [...pathShapes, ...iconShapes];
            
            const randomShape = allShapes[Math.floor(Math.random() * allShapes.length)];
            
            const btn = document.querySelector(`[data-shape="${randomShape}"]`);
            if (btn) btn.click();

            const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            const randomBg = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            
            inputs.color.value = randomColor;
            state.color = randomColor;
            
            if (Math.random() > 0.7) {
                inputs.bgColor.value = randomBg;
                state.bgColor = randomBg;
                inputs.transparentBg.checked = false;
                state.transparentBg = false;
            } else {
                inputs.bgColor.value = "#ffffff";
                state.bgColor = "#ffffff";
            }
            inputs.bgColor.disabled = state.transparentBg;

            const newSize = 20 + Math.floor(Math.random() * 80);
            const newGap = 10 + Math.floor(Math.random() * 80);
            const newRot = Math.floor(Math.random() * 4) * 45;
            
            inputs.size.value = newSize;
            state.size = newSize;
            inputs.gap.value = newGap;
            state.gap = newGap;
            inputs.rotation.value = newRot;
            state.rotation = newRot;

            updateLabels();
            draw();
        }

        // メイン描画関数
        function draw() {
            // ストライプまたはグリッドの場合は専用の描画ロジックへ分岐
            if (state.shape === 'stripe' || state.shape === 'grid') {
                drawLinearPattern();
                return;
            }

            // 通常の図形描画
            drawGeometricPattern();
        }

        // 線形パターン（ストライプ・グリッド）描画ロジック
        function drawLinearPattern() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!state.transparentBg) {
                ctx.fillStyle = state.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            const size = state.size; // ストライプではピッチの一部として利用
            let gap = state.gap;
            
            // シームレスモード計算
            if (state.seamlessMode) {
                let rawPitch = size + gap;
                let count = Math.round(canvas.width / rawPitch);
                if (count < 2) count = 2;
                let adjustedPitch = canvas.width / count;
                gap = adjustedPitch - size; // gapを逆算
            }

            const step = size + gap;

            // スタイル設定
            const hex = state.color.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            const colorString = `rgba(${r}, ${g}, ${b}, ${state.opacity})`;

            ctx.strokeStyle = colorString;
            ctx.lineWidth = state.strokeWidth; // 線の太さはこれを使う
            ctx.lineCap = 'butt'; // 端を直角に

            // 回転のためのコンテキスト保存
            ctx.save();
            
            // キャンバス中心へ移動して回転
            ctx.translate(canvas.width / 2, canvas.height / 2);
            const rad = state.rotation * Math.PI / 180;
            ctx.rotate(rad);

            // 描画範囲の計算（回転しても画面全体を覆うように対角線長を利用）
            const diagonal = Math.sqrt(canvas.width**2 + canvas.height**2);
            const limit = diagonal; // 中心から±limitまで描画

            // ループ描画
            // グリッドやストライプの中心を合わせるためにオフセット計算
            // シームレスの場合は特に中心がズレないように配慮
            
            const start = -limit;
            const end = limit;

            ctx.beginPath();

            // 縦線 (Stripe & Grid)
            // stepごとに線を描画
            // 原点(0,0)を通るように描画することで回転の中心が合う
            for (let x = 0; x <= limit; x += step) {
                // 正方向
                ctx.moveTo(x, -limit);
                ctx.lineTo(x, limit);
                // 負方向（0は重複するので避ける）
                if (x !== 0) {
                    ctx.moveTo(-x, -limit);
                    ctx.lineTo(-x, limit);
                }
            }

            // 横線 (Gridのみ)
            if (state.shape === 'grid') {
                for (let y = 0; y <= limit; y += step) {
                    ctx.moveTo(-limit, y);
                    ctx.lineTo(limit, y);
                    if (y !== 0) {
                        ctx.moveTo(-limit, -y);
                        ctx.lineTo(limit, -y);
                    }
                }
            }
            
            ctx.stroke();
            ctx.restore();
        }

        // 通常の図形パターン描画ロジック (以前のdraw関数)
        function drawGeometricPattern() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!state.transparentBg) {
                ctx.fillStyle = state.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            const size = state.size;
            let gap = state.gap;

            // シームレスモード計算
            if (state.seamlessMode) {
                let rawPitch = size + gap;
                let count = Math.round(canvas.width / rawPitch);
                if (count < 2) count = 2;
                if (state.offsetRow && count % 2 !== 0) {
                     count += 1; 
                }
                let adjustedPitch = canvas.width / count;
                gap = adjustedPitch - size;
            }

            const step = size + gap;
            
            const hex = state.color.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            const colorString = `rgba(${r}, ${g}, ${b}, ${state.opacity})`;

            ctx.fillStyle = colorString;
            ctx.strokeStyle = colorString;
            ctx.lineWidth = state.strokeWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `900 ${size}px "Font Awesome 6 Free"`;

            const rad = state.rotation * Math.PI / 180;
            const margin = step; 
            
            for (let y = -margin; y < canvas.height + margin; y += step) {
                let rowIndex = Math.round(y / step);
                let xOffset = 0;
                if (state.offsetRow) {
                    if (rowIndex % 2 !== 0) xOffset = step / 2;
                }

                for (let x = -margin; x < canvas.width + margin; x += step) {
                    ctx.save();
                    
                    let drawX = x + xOffset + size / 2;
                    let drawY = y + size / 2;

                    if (state.randomizePos) {
                        const pseudoRandom = Math.sin(rowIndex * 12.9898 + (x/step) * 78.233) * 43758.5453;
                        const jitterVal = (pseudoRandom - Math.floor(pseudoRandom)) * (gap / 1.5);
                        drawX += jitterVal;
                        drawY += jitterVal;
                    }

                    ctx.translate(drawX, drawY);
                    ctx.rotate(rad);

                    drawShape(state.shape, 0, 0, size);
                    
                    ctx.restore();
                }
            }
        }

        function drawShape(type, x, y, s) {
            const half = s / 2;
            
            if (faIcons[type]) {
                ctx.fillText(faIcons[type], 0, 0);
                return;
            }

            ctx.beginPath();
            switch (type) {
                case 'circle':
                    ctx.arc(0, 0, half, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'square':
                    ctx.rect(-half, -half, s, s);
                    ctx.fill();
                    break;
                case 'triangle':
                    const h = s * (Math.sqrt(3)/2);
                    ctx.moveTo(0, -h/1.5);
                    ctx.lineTo(-half, h/3);
                    ctx.lineTo(half, h/3);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'cross':
                    ctx.moveTo(-half, -half);
                    ctx.lineTo(half, half);
                    ctx.moveTo(half, -half);
                    ctx.lineTo(-half, half);
                    ctx.stroke();
                    break;
                case 'diamond':
                    ctx.moveTo(0, -half);
                    ctx.lineTo(half, 0);
                    ctx.lineTo(0, half);
                    ctx.lineTo(-half, 0);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'line':
                    ctx.moveTo(-half, 0);
                    ctx.lineTo(half, 0);
                    ctx.stroke();
                    break;
                case 'wave':
                    ctx.moveTo(-half, 0);
                    ctx.quadraticCurveTo(-half/2, -half, 0, 0);
                    ctx.quadraticCurveTo(half/2, half, half, 0);
                    ctx.stroke();
                    break;
                case 'dot':
                    ctx.arc(0, 0, half/3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }
        }

        function downloadImage() {
            const link = document.createElement('a');
            const timestamp = new Date().getTime();
            link.download = `geopattern_${timestamp}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        init();

    </script>
</body>
</html>