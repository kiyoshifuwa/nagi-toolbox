<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Maker | デザイナー向けパターン生成ツール</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome (Web Font) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #fdf2f8; /* pink-50 */
            /* モバイルでのスクロール挙動を改善 */
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* カスタムスクロールバー */
        .custom-scroll::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: transparent;
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background-color: #fbcfe8; /* pink-200 */
            border-radius: 20px;
        }

        .checkered-bg {
            background-image: 
                linear-gradient(45deg, #e5e7eb 25%, transparent 25%, transparent 75%, #e5e7eb 75%),
                linear-gradient(45deg, #e5e7eb 25%, transparent 25%, transparent 75%, #e5e7eb 75%);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }

        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #db2777; /* pink-600 */
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e2e8f0;
            border-radius: 2px;
        }

        .shape-btn i {
            font-size: 1.25rem;
            pointer-events: none;
        }
    </style>
</head>
<!-- flex-col-reverseでモバイル時はプレビュー(main)を上に、設定(aside)を下にする -->
<!-- md:flex-rowでPC時は設定(左)、プレビュー(右)にする -->
<body class="flex flex-col-reverse md:flex-row h-screen text-gray-800 overflow-hidden">

    <!-- 設定パネル (PC: 左側, Mobile: 下側) -->
    <aside class="w-full md:w-80 bg-white shadow-xl z-10 flex flex-col border-r border-gray-200 h-1/2 md:h-full">
        <div class="p-4 md:p-5 border-b border-gray-100 flex justify-between items-center bg-white sticky top-0 z-20">
            <h1 class="text-lg md:text-xl font-bold text-pink-600 flex items-center gap-2">
                <i class="fa-solid fa-shapes"></i> Pattern Maker
            </h1>
            <button id="randomBtn" class="text-xs bg-pink-50 text-pink-600 px-3 py-1 rounded hover:bg-pink-100 transition" title="ランダム生成">
                <i class="fa-solid fa-dice"></i> Random
            </button>
        </div>

        <div class="flex-1 overflow-y-auto custom-scroll p-4 md:p-5 space-y-6">
            
            <!-- Shape Selection -->
            <div class="space-y-2">
                <label class="text-xs font-bold text-gray-500 uppercase tracking-wider">図形 (Shape)</label>
                <div class="grid grid-cols-4 gap-2">
                    
                    <!-- Line Patterns -->
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="stripe" title="ストライプ">
                        <i class="fa-solid fa-grip-lines-vertical text-gray-600 text-sm"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="grid" title="方眼 (グリッド)">
                        <i class="fa-solid fa-border-all text-gray-600 text-sm"></i>
                    </button>
                    
                    <!-- Basic Geometry -->
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="circle" title="円">
                        <i class="fa-regular fa-circle text-gray-600 text-sm"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="square" title="四角">
                        <i class="fa-regular fa-square text-gray-600 text-sm"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="triangle" title="三角">
                        <i class="fa-solid fa-play -rotate-90 text-[10px] text-gray-600"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="cross" title="バツ">
                        <i class="fa-solid fa-xmark text-gray-600 text-sm"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="diamond" title="ひし形">
                        <i class="fa-solid fa-diamond text-[10px] text-gray-600"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="wave" title="波線">
                        <i class="fa-solid fa-water text-gray-600 text-xs"></i>
                    </button>
                    
                    <!-- Font Awesome Icons -->
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="star" title="星">
                        <i class="fa-solid fa-star text-gray-600 text-xs"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="heart" title="ハート">
                        <i class="fa-solid fa-heart text-gray-600 text-xs"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="bolt" title="稲妻">
                        <i class="fa-solid fa-bolt text-gray-600 text-xs"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="moon" title="月">
                        <i class="fa-solid fa-moon text-gray-600 text-xs"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="cloud" title="雲">
                        <i class="fa-solid fa-cloud text-gray-600 text-xs"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="leaf" title="葉">
                        <i class="fa-solid fa-leaf text-gray-600 text-xs"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="snowflake" title="雪">
                        <i class="fa-solid fa-snowflake text-gray-600 text-xs"></i>
                    </button>
                    <button class="shape-btn p-2 rounded border border-gray-200 hover:border-pink-500 hover:bg-pink-50 transition flex justify-center items-center h-10" data-shape="flower" title="花">
                        <i class="fa-solid fa-spa text-gray-600 text-xs"></i>
                    </button>
                </div>
            </div>

            <!-- Seamless Mode Switch -->
            <div class="bg-pink-50 p-3 rounded-lg border border-pink-100">
                <label class="flex items-center gap-3 cursor-pointer">
                    <div class="relative">
                        <input type="checkbox" id="seamlessMode" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-300 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-pink-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-pink-600"></div>
                    </div>
                    <div class="flex flex-col">
                        <span class="text-sm font-bold text-pink-900">シームレスモード</span>
                        <span class="text-[10px] text-pink-700 leading-tight">端が繋がるよう自動調整</span>
                    </div>
                </label>
            </div>

            <!-- Colors -->
            <div class="space-y-3">
                <label class="text-xs font-bold text-gray-500 uppercase tracking-wider">カラー (Colors)</label>
                <div class="flex items-center justify-between">
                    <span class="text-sm text-gray-600">図形/線色</span>
                    <div class="flex items-center gap-2">
                        <input type="color" id="shapeColor" value="#333333" class="w-8 h-8 rounded cursor-pointer border-0 p-0">
                        <input type="range" id="opacity" min="0.1" max="1" step="0.1" value="1" class="w-20" title="不透明度">
                    </div>
                </div>
                <div class="flex items-center justify-between">
                    <span class="text-sm text-gray-600">背景色</span>
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="transparentBg" class="w-4 h-4 text-pink-600 rounded focus:ring-pink-500" title="透明背景">
                        <span class="text-xs text-gray-400 mr-2">透明</span>
                        <input type="color" id="bgColor" value="#ffffff" class="w-8 h-8 rounded cursor-pointer border-0 p-0">
                    </div>
                </div>
            </div>

            <!-- Parameters -->
            <div class="space-y-4">
                <label class="text-xs font-bold text-gray-500 uppercase tracking-wider">パラメーター (Params)</label>
                
                <div class="space-y-1">
                    <div class="flex justify-between text-sm">
                        <span>サイズ (Spacing Adjust)</span>
                        <span id="sizeVal" class="text-gray-400 text-xs">30px</span>
                    </div>
                    <input type="range" id="size" min="2" max="150" value="30" class="w-full">
                </div>

                <div class="space-y-1">
                    <div class="flex justify-between text-sm">
                        <span>間隔 (Gap)</span>
                        <span id="gapVal" class="text-gray-400 text-xs">40px</span>
                    </div>
                    <input type="range" id="gap" min="0" max="200" value="40" class="w-full">
                </div>

                <div class="space-y-1">
                    <div class="flex justify-between text-sm">
                        <span>回転 (Rotation)</span>
                        <span id="rotVal" class="text-gray-400 text-xs">0°</span>
                    </div>
                    <input type="range" id="rotation" min="0" max="360" value="0" class="w-full">
                </div>
                
                 <div class="space-y-1">
                    <div class="flex justify-between text-sm">
                        <span>線の太さ (Stroke)</span>
                        <span id="strokeVal" class="text-gray-400 text-xs">Normal</span>
                    </div>
                    <input type="range" id="strokeWidth" min="1" max="50" value="2" class="w-full">
                    <p class="text-[10px] text-gray-400">*バツやライン、ストライプに有効</p>
                </div>
            </div>

            <!-- Layout Options -->
            <div class="space-y-3">
                <label class="text-xs font-bold text-gray-500 uppercase tracking-wider">レイアウト (Layout)</label>
                
                <label class="flex items-center gap-2 cursor-pointer p-2 rounded hover:bg-gray-50">
                    <input type="checkbox" id="offsetRow" class="w-4 h-4 text-pink-600 rounded focus:ring-pink-500" checked>
                    <span class="text-sm text-gray-700">千鳥配置 (Offset Rows)</span>
                </label>
                
                <label class="flex items-center gap-2 cursor-pointer p-2 rounded hover:bg-gray-50">
                    <input type="checkbox" id="randomizePos" class="w-4 h-4 text-pink-600 rounded focus:ring-pink-500">
                    <span class="text-sm text-gray-700">位置を少しランダムに (Jitter)</span>
                    <span class="text-[10px] text-red-400 ml-1 hidden" id="jitterWarning">※シームレスにはなりません</span>
                </label>
            </div>

            <!-- Spacing for mobile scroll -->
            <div class="h-10 md:hidden"></div>

        </div>

        <!-- Action Buttons -->
        <div class="p-4 md:p-5 border-t border-gray-200 bg-gray-50">
            <div class="flex gap-2">
                <button id="downloadBtn" class="flex-1 bg-pink-600 text-white font-semibold py-3 px-2 rounded-lg shadow hover:bg-pink-700 transition flex justify-center items-center gap-2 text-sm md:text-base">
                    <i class="fa-solid fa-download"></i> PNG
                </button>
                <button id="downloadSvgBtn" class="flex-1 bg-white border border-pink-300 text-pink-600 font-semibold py-3 px-2 rounded-lg shadow hover:bg-pink-50 transition flex justify-center items-center gap-2 text-sm md:text-base">
                    <i class="fa-solid fa-file-code"></i> SVG
                </button>
            </div>
            <p class="text-xs text-center text-gray-400 mt-2">2000 x 2000px</p>
        </div>
    </aside>

    <!-- プレビューエリア (PC: 右側, Mobile: 上側) -->
    <main class="flex-1 relative flex flex-col min-w-0 h-1/2 md:h-full bg-gray-100 overflow-hidden">
        <!-- キャンバスエリア -->
        <div class="flex-1 relative flex items-center justify-center p-4 md:p-10 checkered-bg h-full">
            <div class="relative shadow-2xl bg-white max-w-full max-h-full aspect-square">
                <!-- 実際に描画されるキャンバス -->
                <canvas id="mainCanvas" width="2000" height="2000" class="w-full h-full object-contain block"></canvas>
                
                <!-- サイズ表示ラベル -->
                <div class="absolute -top-6 left-0 text-xs text-gray-500 font-mono">Preview</div>
                <!-- シームレス表示バッジ -->
                <div id="seamlessBadge" class="absolute top-2 right-2 bg-pink-600 text-white text-[10px] px-2 py-1 rounded shadow hidden">Seamless ON</div>
            </div>
        </div>
    </main>

    <script>
        // DOM要素
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        
        // 状態管理
        const state = {
            shape: 'stripe', 
            color: '#333333',
            opacity: 1,
            bgColor: '#ffffff',
            transparentBg: false,
            size: 30,
            gap: 40,
            rotation: 0,
            strokeWidth: 2,
            offsetRow: true,
            randomizePos: false,
            seamlessMode: false,
            canvasSize: 2000
        };

        const inputs = {
            shapeBtns: document.querySelectorAll('.shape-btn'),
            color: document.getElementById('shapeColor'),
            opacity: document.getElementById('opacity'),
            bgColor: document.getElementById('bgColor'),
            transparentBg: document.getElementById('transparentBg'),
            size: document.getElementById('size'),
            gap: document.getElementById('gap'),
            rotation: document.getElementById('rotation'),
            strokeWidth: document.getElementById('strokeWidth'),
            offsetRow: document.getElementById('offsetRow'),
            randomizePos: document.getElementById('randomizePos'),
            seamlessMode: document.getElementById('seamlessMode'),
            downloadBtn: document.getElementById('downloadBtn'),
            downloadSvgBtn: document.getElementById('downloadSvgBtn'),
            randomBtn: document.getElementById('randomBtn')
        };

        const labels = {
            size: document.getElementById('sizeVal'),
            gap: document.getElementById('gapVal'),
            rotation: document.getElementById('rotVal'),
            stroke: document.getElementById('strokeVal')
        };

        const jitterWarning = document.getElementById('jitterWarning');
        const seamlessBadge = document.getElementById('seamlessBadge');

        // Font Awesome Icons Map (Unicode)
        const faIcons = {
            'star': '\uf005',
            'heart': '\uf004',
            'bolt': '\uf0e7',
            'moon': '\uf186',
            'cloud': '\uf0c2',
            'leaf': '\uf06c',
            'snowflake': '\uf2dc',
            'flower': '\uf06c', 
            'music': '\uf001',
            'ghost': '\uf6e2',
            'cat': '\uf6be',
            'paw': '\uf1b0'
        };

        function init() {
            addEventListeners();
            updateUI();
            document.fonts.ready.then(() => { draw(); });
            draw();
        }

        function addEventListeners() {
            inputs.shapeBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    inputs.shapeBtns.forEach(b => {
                        b.classList.remove('border-pink-500', 'bg-pink-50', 'ring-2', 'ring-pink-200');
                        b.classList.add('border-gray-200');
                    });
                    const target = e.currentTarget;
                    target.classList.remove('border-gray-200');
                    target.classList.add('border-pink-500', 'bg-pink-50', 'ring-2', 'ring-pink-200');
                    state.shape = target.dataset.shape;
                    draw();
                });
            });

            // UI同期
            const activeBtn = document.querySelector(`[data-shape="${state.shape}"]`);
            if(activeBtn) {
                activeBtn.classList.remove('border-gray-200');
                activeBtn.classList.add('border-pink-500', 'bg-pink-50', 'ring-2', 'ring-pink-200');
            }

            const updateStateAndDraw = (key, value) => {
                state[key] = value;
                updateLabels();
                draw();
            };

            inputs.color.addEventListener('input', e => updateStateAndDraw('color', e.target.value));
            inputs.opacity.addEventListener('input', e => updateStateAndDraw('opacity', parseFloat(e.target.value)));
            inputs.bgColor.addEventListener('input', e => updateStateAndDraw('bgColor', e.target.value));
            
            inputs.transparentBg.addEventListener('change', e => {
                state.transparentBg = e.target.checked;
                inputs.bgColor.disabled = state.transparentBg;
                inputs.bgColor.parentElement.style.opacity = state.transparentBg ? 0.5 : 1;
                draw();
            });

            inputs.size.addEventListener('input', e => updateStateAndDraw('size', parseInt(e.target.value)));
            inputs.gap.addEventListener('input', e => updateStateAndDraw('gap', parseInt(e.target.value)));
            inputs.rotation.addEventListener('input', e => updateStateAndDraw('rotation', parseInt(e.target.value)));
            inputs.strokeWidth.addEventListener('input', e => updateStateAndDraw('strokeWidth', parseInt(e.target.value)));
            
            inputs.offsetRow.addEventListener('change', e => updateStateAndDraw('offsetRow', e.target.checked));
            inputs.randomizePos.addEventListener('change', e => updateStateAndDraw('randomizePos', e.target.checked));
            inputs.seamlessMode.addEventListener('change', e => updateStateAndDraw('seamlessMode', e.target.checked));

            inputs.downloadBtn.addEventListener('click', downloadImage);
            inputs.downloadSvgBtn.addEventListener('click', downloadSvg);
            inputs.randomBtn.addEventListener('click', generateRandom);
        }

        function updateLabels() {
            labels.size.textContent = `${state.size}px`;
            labels.gap.textContent = `${state.gap}px`;
            labels.rotation.textContent = `${state.rotation}°`;
            labels.stroke.textContent = `${state.strokeWidth}px`;
            
            if(state.seamlessMode && state.randomizePos) jitterWarning.classList.remove('hidden');
            else jitterWarning.classList.add('hidden');

            if(state.seamlessMode) seamlessBadge.classList.remove('hidden');
            else seamlessBadge.classList.add('hidden');

            if (state.shape === 'stripe' || state.shape === 'grid') {
                inputs.offsetRow.parentElement.classList.add('opacity-50', 'pointer-events-none');
                inputs.randomizePos.parentElement.classList.add('opacity-50', 'pointer-events-none');
            } else {
                inputs.offsetRow.parentElement.classList.remove('opacity-50', 'pointer-events-none');
                inputs.randomizePos.parentElement.classList.remove('opacity-50', 'pointer-events-none');
            }
        }

        function updateUI() {
            inputs.color.value = state.color;
            inputs.size.value = state.size;
            inputs.gap.value = state.gap;
            inputs.rotation.value = state.rotation;
            inputs.seamlessMode.checked = state.seamlessMode;
            updateLabels();
        }

        function generateRandom() {
            const pathShapes = ['circle', 'square', 'triangle', 'cross', 'diamond', 'line', 'wave', 'dot', 'stripe', 'grid'];
            const iconShapes = Object.keys(faIcons);
            const allShapes = [...pathShapes, ...iconShapes];
            const randomShape = allShapes[Math.floor(Math.random() * allShapes.length)];
            
            const btn = document.querySelector(`[data-shape="${randomShape}"]`);
            if (btn) btn.click();

            const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            const randomBg = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            
            inputs.color.value = randomColor;
            state.color = randomColor;
            
            if (Math.random() > 0.7) {
                inputs.bgColor.value = randomBg;
                state.bgColor = randomBg;
                inputs.transparentBg.checked = false;
                state.transparentBg = false;
            } else {
                inputs.bgColor.value = "#ffffff";
                state.bgColor = "#ffffff";
            }
            inputs.bgColor.disabled = state.transparentBg;

            const newSize = 20 + Math.floor(Math.random() * 80);
            const newGap = 10 + Math.floor(Math.random() * 80);
            const newRot = Math.floor(Math.random() * 4) * 45;
            
            inputs.size.value = newSize;
            state.size = newSize;
            inputs.gap.value = newGap;
            state.gap = newGap;
            inputs.rotation.value = newRot;
            state.rotation = newRot;

            updateLabels();
            draw();
        }

        // --- Drawing Logic ---

        function getCalculatedParams() {
             const size = state.size;
             let gap = state.gap;
             let count = 0;

             if (state.seamlessMode) {
                let rawPitch = size + gap;
                count = Math.round(canvas.width / rawPitch);
                if (count < 2) count = 2;
                
                // ストライプ/グリッド以外でOffsetRowが有効な場合、偶数行にする
                if (state.shape !== 'stripe' && state.shape !== 'grid') {
                    if (state.offsetRow && count % 2 !== 0) count += 1; 
                }
                
                let adjustedPitch = canvas.width / count;
                gap = adjustedPitch - size;
             }
             return { size, gap, step: size + gap };
        }

        function draw() {
            if (state.shape === 'stripe' || state.shape === 'grid') {
                drawLinearPattern();
            } else {
                drawGeometricPattern();
            }
        }

        function drawLinearPattern() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!state.transparentBg) {
                ctx.fillStyle = state.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            const { size, gap, step } = getCalculatedParams();
            
            const hex = state.color.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            const colorString = `rgba(${r}, ${g}, ${b}, ${state.opacity})`;

            ctx.strokeStyle = colorString;
            ctx.lineWidth = state.strokeWidth; 
            ctx.lineCap = 'butt'; 

            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            const rad = state.rotation * Math.PI / 180;
            ctx.rotate(rad);

            const diagonal = Math.sqrt(canvas.width**2 + canvas.height**2);
            const limit = diagonal; 
            
            ctx.beginPath();
            for (let x = 0; x <= limit; x += step) {
                ctx.moveTo(x, -limit); ctx.lineTo(x, limit);
                if (x !== 0) { ctx.moveTo(-x, -limit); ctx.lineTo(-x, limit); }
            }

            if (state.shape === 'grid') {
                for (let y = 0; y <= limit; y += step) {
                    ctx.moveTo(-limit, y); ctx.lineTo(limit, y);
                    if (y !== 0) { ctx.moveTo(-limit, -y); ctx.lineTo(limit, -y); }
                }
            }
            
            ctx.stroke();
            ctx.restore();
        }

        function drawGeometricPattern() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!state.transparentBg) {
                ctx.fillStyle = state.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            const { size, gap, step } = getCalculatedParams();
            
            const hex = state.color.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            const colorString = `rgba(${r}, ${g}, ${b}, ${state.opacity})`;

            ctx.fillStyle = colorString;
            ctx.strokeStyle = colorString;
            ctx.lineWidth = state.strokeWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `900 ${size}px "Font Awesome 6 Free"`;

            const rad = state.rotation * Math.PI / 180;
            const margin = step; 
            
            for (let y = -margin; y < canvas.height + margin; y += step) {
                let rowIndex = Math.round(y / step);
                let xOffset = 0;
                if (state.offsetRow) {
                    if (rowIndex % 2 !== 0) xOffset = step / 2;
                }

                for (let x = -margin; x < canvas.width + margin; x += step) {
                    ctx.save();
                    
                    let drawX = x + xOffset + size / 2;
                    let drawY = y + size / 2;

                    if (state.randomizePos) {
                        const pseudoRandom = Math.sin(rowIndex * 12.9898 + (x/step) * 78.233) * 43758.5453;
                        const jitterVal = (pseudoRandom - Math.floor(pseudoRandom)) * (gap / 1.5);
                        drawX += jitterVal;
                        drawY += jitterVal;
                    }

                    ctx.translate(drawX, drawY);
                    ctx.rotate(rad);
                    drawShape(ctx, state.shape, 0, 0, size);
                    ctx.restore();
                }
            }
        }

        function drawShape(context, type, x, y, s) {
            const half = s / 2;
            if (faIcons[type]) {
                context.fillText(faIcons[type], 0, 0);
                return;
            }
            context.beginPath();
            switch (type) {
                case 'circle': context.arc(0, 0, half, 0, Math.PI * 2); context.fill(); break;
                case 'square': context.rect(-half, -half, s, s); context.fill(); break;
                case 'triangle':
                    const h = s * (Math.sqrt(3)/2);
                    context.moveTo(0, -h/1.5); context.lineTo(-half, h/3); context.lineTo(half, h/3);
                    context.closePath(); context.fill();
                    break;
                case 'cross':
                    context.moveTo(-half, -half); context.lineTo(half, half);
                    context.moveTo(half, -half); context.lineTo(-half, half);
                    context.stroke();
                    break;
                case 'diamond':
                    context.moveTo(0, -half); context.lineTo(half, 0); context.lineTo(0, half); context.lineTo(-half, 0);
                    context.closePath(); context.fill(); break;
                case 'line': context.moveTo(-half, 0); context.lineTo(half, 0); context.stroke(); break;
                case 'wave':
                    context.moveTo(-half, 0);
                    context.quadraticCurveTo(-half/2, -half, 0, 0);
                    context.quadraticCurveTo(half/2, half, half, 0);
                    context.stroke(); break;
                case 'dot': context.arc(0, 0, half/3, 0, Math.PI * 2); context.fill(); break;
            }
        }

        function downloadImage() {
            const link = document.createElement('a');
            const timestamp = new Date().getTime();
            link.download = `pattern_${timestamp}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // --- SVG Export Logic ---
        
        function downloadSvg() {
            const { size, gap, step } = getCalculatedParams();
            const width = state.canvasSize;
            const height = state.canvasSize;
            const hex = state.color;
            const opacity = state.opacity;
            const strokeW = state.strokeWidth;
            
            // Background
            let svgContent = `<rect width="100%" height="100%" fill="${state.transparentBg ? 'none' : state.bgColor}" />`;
            
            // Common styles
            const fillAttr = `fill="${hex}" fill-opacity="${opacity}"`;
            const strokeAttr = `stroke="${hex}" stroke-opacity="${opacity}" stroke-width="${strokeW}" stroke-linecap="round" stroke-linejoin="round" fill="none"`;
            
            if (state.shape === 'stripe' || state.shape === 'grid') {
                // Linear Pattern SVG
                const diagonal = Math.sqrt(width**2 + height**2);
                const limit = diagonal;
                let paths = "";
                
                // Group with transform for rotation (centered)
                const rot = state.rotation;
                
                // Lines
                for (let x = 0; x <= limit; x += step) {
                     paths += `<line x1="${x}" y1="${-limit}" x2="${x}" y2="${limit}" />`;
                     if (x!==0) paths += `<line x1="${-x}" y1="${-limit}" x2="${-x}" y2="${limit}" />`;
                }
                if (state.shape === 'grid') {
                    for (let y = 0; y <= limit; y += step) {
                        paths += `<line x1="${-limit}" y1="${y}" x2="${limit}" y2="${y}" />`;
                        if (y!==0) paths += `<line x1="${-limit}" y1="${-y}" x2="${limit}" y2="${-y}" />`;
                    }
                }
                
                svgContent += `<g transform="translate(${width/2}, ${height/2}) rotate(${rot})">
                                <g ${strokeAttr.replace('stroke-linecap="round"', 'stroke-linecap="butt"')}>${paths}</g>
                               </g>`;
            } else {
                // Geometric Pattern SVG
                const margin = step;
                let shapes = "";
                
                for (let y = -margin; y < height + margin; y += step) {
                    let rowIndex = Math.round(y / step);
                    let xOffset = 0;
                    if (state.offsetRow) {
                        if (rowIndex % 2 !== 0) xOffset = step / 2;
                    }

                    for (let x = -margin; x < width + margin; x += step) {
                        let drawX = x + xOffset + size / 2;
                        let drawY = y + size / 2;
                        
                        if (state.randomizePos) {
                            const pseudoRandom = Math.sin(rowIndex * 12.9898 + (x/step) * 78.233) * 43758.5453;
                            const jitterVal = (pseudoRandom - Math.floor(pseudoRandom)) * (gap / 1.5);
                            drawX += jitterVal;
                            drawY += jitterVal;
                        }

                        // Shapes
                        const rot = state.rotation;
                        // Each shape is a group with transform
                        shapes += `<g transform="translate(${drawX}, ${drawY}) rotate(${rot})">`;
                        shapes += getSvgShape(state.shape, size, fillAttr, strokeAttr);
                        shapes += `</g>`;
                    }
                }
                svgContent += shapes;
            }

            const svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">${svgContent}</svg>`;
            
            const blob = new Blob([svgString], {type: 'image/svg+xml'});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = `pattern_${new Date().getTime()}.svg`;
            link.href = url;
            link.click();
        }

        function getSvgShape(type, s, fillAttr, strokeAttr) {
            const half = s/2;
            if (faIcons[type]) {
                // Text for icons (Note: requires font installed locally or embedded to work perfectly in external tools)
                // We convert unicode char to hex entity
                const code = faIcons[type].charCodeAt(0).toString(16);
                return `<text x="0" y="0" dominant-baseline="central" text-anchor="middle" font-family="Font Awesome 6 Free" font-weight="900" font-size="${s}" ${fillAttr}>&#x${code};</text>`;
            }
            
            switch (type) {
                case 'circle': return `<circle cx="0" cy="0" r="${half}" ${fillAttr} />`;
                case 'square': return `<rect x="${-half}" y="${-half}" width="${s}" height="${s}" ${fillAttr} />`;
                case 'triangle':
                    const h = s * (Math.sqrt(3)/2);
                    return `<polygon points="0,${-h/1.5} ${-half},${h/3} ${half},${h/3}" ${fillAttr} />`;
                case 'cross':
                    return `<g ${strokeAttr}>
                        <line x1="${-half}" y1="${-half}" x2="${half}" y2="${half}" />
                        <line x1="${half}" y1="${-half}" x2="${-half}" y2="${half}" />
                    </g>`;
                case 'diamond':
                     return `<polygon points="0,${-half} ${half},0 0,${half} ${-half},0" ${fillAttr} />`;
                case 'line': return `<line x1="${-half}" y1="0" x2="${half}" y2="0" ${strokeAttr} />`;
                case 'wave':
                     return `<path d="M${-half},0 Q${-half/2},${-half} 0,0 T${half},0" fill="none" ${strokeAttr} />`;
                case 'dot': return `<circle cx="0" cy="0" r="${half/3}" ${fillAttr} />`;
            }
            return "";
        }

        init();

    </script>
</body>
</html>